# CS202: Computer Organization Project Report



## 一、开发人员及开发计划

### 1、开发者说明

| 开发者人员           | 开发任务                                                     | 贡献比 |
| :------------------- | :----------------------------------------------------------- | :----- |
| 何佳轩<br />12210624 |                                                              | 1/3    |
| 廖宇凡<br />12210626 |                                                              | 1/3    |
| 杨彦卓<br />12212726 | 顶层模块初稿、Ifetch模块编写及调试<br />基本测试场景2的asm文件编写及调试<br />项目报告撰写 | 1/3    |

### 2、开发计划

| 时间   | 日程安排                                                     | 实施情况 |
| :----- | :----------------------------------------------------------- | :------- |
| 第12周 | CPU子模块设计以及调试                                        | 基本完成 |
| 第13周 | CPU子模块汇总以及顶层模块设计<br />中期答辩<br />实现并调试基本测试场景1 | 基本完成 |
| 第14周 | 实现并调试基本测试场景2<br />撰写项目报告                    | 基本完成 |
| 第15周 | 答辩<br />继续调试CPU的Verilog代码<br />继续调试asm文件代码  | 未完成   |
| 第16周 | 答辩                                                         | 完成     |





## 二、CPU架构设计说明

### 1、CPU特性

#### 1.1 ISA及其参考

该CPU参考`RISC-V`指令集架构(ISA)，并承载32个`32-bits`寄存器，且左侧储存高位。下面是该CPU支持的一些`RISC-V`指令，包括指令名称、对应编码和使用方式：

##### R-Type指令：

| 指令名称 | funct7  | rs2  | rs1  | funct3 | rd   | opcode  | 使用方式           |
| -------- | ------- | ---- | ---- | ------ | ---- | ------- | ------------------ |
| `ADD`    | 0000000 | rs2  | rs1  | 000    | rd   | 0110011 | `add rd, rs1, rs2` |
| `AND`    | 0000000 | rs2  | rs1  | 111    | rd   | 0110011 | `and rd, rs1, rs2` |
| `OR`     | 0000000 | rs2  | rs1  | 110    | rd   | 0110011 | `or rd, rs1, rs2`  |
| `XOR`    | 0000000 | rs2  | rs1  | 100    | rd   | 0110011 | `xor rd, rs1, rs2` |
| `SLL`    | 0000000 | rs2  | rs1  | 001    | rd   | 0110011 | `sll rd, rs1, rs2` |
| `SRL`    | 0000000 | rs2  | rs1  | 101    | rd   | 0110011 | `srl rd, rs1, rs2` |
| `SRA`    | 0100000 | rs2  | rs1  | 101    | rd   | 0110011 | `sra rd, rs1, rs2` |

##### I-Type指令：

| 指令名称 | imm[11:0] | rs1  | funct3 | rd   | opcode  | 使用方式            |
| -------- | --------- | ---- | ------ | ---- | ------- | ------------------- |
| `ADDI`   | imm[11:0] | rs1  | 000    | rd   | 0010011 | `addi rd, rs1, imm` |
| `ANDI`   | imm[11:0] | rs1  | 111    | rd   | 0010011 | `andi rd, rs1, imm` |
| `ORI`    | imm[11:0] | rs1  | 110    | rd   | 0010011 | `ori rd, rs1, imm`  |
| `XORI`   | imm[11:0] | rs1  | 100    | rd   | 0010011 | `xori rd, rs1, imm` |
| `SLLI`   | imm[4:0]  | rs1  | 001    | rd   | 0010011 | `slli rd, rs1, imm` |
| `SRLI`   | imm[4:0]  | rs1  | 101    | rd   | 0010011 | `srli rd, rs1, imm` |
| `LW`     | imm[11:0] | rs1  | 010    | rd   | 0000011 | `lw rd, imm(rs1)`   |

##### S-Type指令：

| 指令名称 | rs2  | rs1  | funct3 | opcode  | 使用方式           |
| -------- | ---- | ---- | ------ | ------- | ------------------ |
| `SW`     | rs2  | rs1  | 010    | 0100011 | `sw rs2, imm(rs1)` |

##### B-Type指令：

| 指令名称 | funct3 | 使用方式            |
| -------- | ------ | ------------------- |
| `BEQ`    | 000    | `beq rs1, rs2, imm` |
| `BNE`    | 001    | `bne rs1, rs2, imm` |
| `BLT`    | 100    | `blt rs1, rs2, imm` |
| `BGE`    | 101    | `bge rs1, rs2, imm` |

##### J-Type指令：

| 指令  | opcode  | funct3 | 使用方式               |
| ----- | ------- | ------ | ---------------------- |
| `JAL` | 1101111 | -      | `jal rd, offset`       |
| `JR`  | 1100111 | 3'b000 | `jalr rd, rs1, offset` |

##### U-Type指令：

| 指令    | opcode  | 使用方式        |
| ------- | ------- | --------------- |
| `LUI`   | 0110111 | `lui rd, imm`   |
| `AUIPC` | 0010111 | `auipc rd, imm` |



#### 1.2 CPU设计

该CPU为单周期设计。平均来看，每条指令都在一个周期内完成，所以`CPI`约为`1`。



#### 1.3 寻址空间设计

该CPU采用哈佛结构，数据和指令在存储层面相互独立，但所有数据和指令位宽都为`32-bits`。寻址单位为`32-bits`，指令空间起始地址为`0x00000000`，数据空间起始地址为`0x00000000`，两者深度均为$2^{14}$。栈空间基地址为`0x00000000`。



#### 1.4 外设I/O设计

对于外设该项目采用MMIO访问并读写外设，外设对应的地址起始空间为`0x00000000`，并采用轮询机制访问I/O。通过引入了一个特别的寄存器a7来连接：

| a7   | 说明                   |
| ---- | ---------------------- |
| 0    | 确认读入的数据         |
| 1    | 读入`8-bits`有符号数   |
| 2    | 读入测试案例编号       |
| 3    | 读入`8-bits`无符号数   |
| 4    | 将结果写出至led灯      |
| 5    | 将结果写出至八段数码管 |







### 2、CPU 内部结构

#### 2.1 CPU内部部分核心子模块接口连接关系以及端口规模示意图

![img](file:///C:\Users\Eric\Documents\Tencent Files\1846688234\Image\Group2\CU\A5\CUA54O0X3IZDJMCWLEVJV{7.png)

![image-20240603153342925](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20240603153342925.png)



![image-20240603153400603](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20240603153400603.png)



![img](file:///C:\Users\Eric\Documents\Tencent Files\1846688234\Image\Group2\@]\SF\@]SFI7%W@TB7CZ04O[9`DW1.png)



![image-20240603153534751](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20240603153534751.png)



![image-20240603153752567](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20240603153752567.png)

​	



#### 2.2 CPU子模块的设计说明

| 子模块名称   | 功能说明                                                     |
| :----------- | :----------------------------------------------------------- |
| `CPU`        | 集成各个子模块，处理指令的获取、解码和执行                   |
| `debounce`   | 用于对输入信号的消抖                                         |
| `IFetch`     | 获取指令并计算出下一个PC的值同时储存某些指令所需的地址       |
| `dmemory32`  | 存储及读写数据                                               |
| `control32`  | 处理传入参数并生成各部分控制信号                             |
| `decoder`    | 内含32个`32-bits`寄存器，用于读写目标数据                    |
| `MemOrIO`    | 连接CPU与内存或I/O设备并控制数据在I/O设备或者内存上的读写    |
| `ALU`        | 计算单元，用于计算数学计算过程与分支或跳转控制信号           |
| `programrom` | 根据输入的地址和时钟信号输出指令，同时支持通过 UART 接口进行编程 |
| `imm32`      | 执行符号位扩展，用于将二进制数补全至`32-bits`                |
| `Led`        | 控制led灯来表示二进制数                                      |
| `light`      | 控制数码管来显示信息                                         |



### 3、CPU接口

​	本项目改写了实验课提供的23Mhz：降低频率至8Mhz；复位键直接使用的开发板提供的实体按键。按下复位键之后会重置pc为0，重置32个寄存器为0。





## 三、使用说明

### 1、系统上板使用说明



![image-20240603154728685](C:\Users\Eric\AppData\Roaming\Typora\typora-user-images\image-20240603154728685.png)



### 2、自测试

开发过程中的主要测试如下：

| 测试场景编号 | 测试方法 | 测试类型 | 测试描述                       | 测试结果                                                     |
| ------------ | -------- | -------- | ------------------------------ | ------------------------------------------------------------ |
| 1            | 仿真测试 | 集成     | 测试各模块关系连接的正确性     | 基本正确<br />修复了已知bug                                  |
| 2            | 仿真测试 | 集成     | 测试R型、I型指令的正确性       | 基本正确<br />修复了已知bug                                  |
| 3            | 仿真测试 | 集成     | 测试其他指令的正确性           | 基本正确<br />修复了已知bug                                  |
| 4            | 上版测试 | 集成     | 测试asm实现的测试场景1的正确性 | 基本正确<br />修改了部分ALU、control模块，增添了一些指令     |
| 5            | 上版测试 | 集成     | 测试asm实现的测试场景2的正确性 | 基本正确<br />修复了已知bug，增添了一些指令用于适应测试场景2 |







## 四、Bonus设计

### 1、设计思路与周边模块关系

lui指令的实现于ALU模块中的一个分支，当opcode判断至一定分支条件后会根据输入值赋值给相应的ALUResult。后续操作与其他指令实现原理一致。

ecall：通过a7寄存器的值来判断执行什么操作。a7=0读入confirm到a0，
a7=1读入8bit有符号数到a0，a7=2读入testcase index到a0，a7=3读入8bit无符号数到a0，a7=4把a0的值输出到led灯
uart：

（——coe？？)





### 2、核心代码

*lui实现*
```verilog
2'b11: ALUResult = (realData << 12);  //lui in ALU module
```



​	这一行代码的逻辑是：通过opcode判断到了正确的分支后，将输入数据`realData`向左移动12位后赋值给`ALUResult`，实现了加载立即数到高位的效果

*ecall实现*
```verilog
if(ioRead)begin
if(rega7==1||rega7==3)begin 
if(rega7==1)
r_wdata={{24{io_rdata[7]}},io_rdata};
else r_wdata=io_rdata;
end
else if(rega7==0)r_wdata=ConfirmCtrl; //confirm
else if(rega7==2)
begin
r_wdata=test_index;//index
data1=test_index;
end
else r_wdata=0;
end
//...
assign LEDCtrl=((ioWrite==1)&&rega7==4)?1'b1:1'b0;
```



### 3、测试说明

​	对于lui指令，在基本测试场景2中的前四个对于四舍五入的实现均有大量涉及：主要是为了直接加载出较大的立即数，来执行后续分割；对于ecall指令，几乎贯通所有asm文件的测试。



## 五、问题及思考总结

### 1. 开发过程中的问题

- **仿真测试**: 仿真测试中可能遇到的各种bug，需要反复调试和修正。

- **上板测试**: 实际硬件环境中可能出现与仿真不一致的问题，尤其是在时序、信号稳定性等方面。

- **模块化设计**: 各子模块的接口和功能是否清晰，是否容易扩展和维护。

- **文档与注释**: 代码中的注释和文档是否详细，是否便于后续开发和维护人员理解和使用。

    

### 2. 思考与总结

- **代码管理与文档化**: 良好的代码管理和文档化习惯是项目顺利进行的保障，应持续完善代码注释和开发文档。

- **迭代与反馈**: 在开发过程中，及时的迭代和反馈非常重要，应建立历史版本存档，以快速响应和解决问题。
- **团队合作与沟通**: 开发项目需要团队合作，各成员之间的沟通与协作至关重要，应共同进行交流和讨论，共同推进项目进展。



​	通过本次CPU项目设计，我们学会了如何做到良好的团队分工配合，对已有的计算机组成原理课程内容进行了巩固与实践。
